
import * as FS from "node:fs/promises";
import * as Path from "node:path";

const url = "https://raw.githubusercontent.com/microsoft/TypeScript/main/src/lib/dom.generated.d.ts";
const domLib = await (await global.fetch(url)).text();

const propertyMap = new Map<string, {
	definitions: Set<string>;
	validFor: Set<string>;
	deprecated: boolean;
	readonly: boolean;
}>();

const functionMap = new Map<string, {
	overloads: Set<string>,
	validFor: Set<string>,
	deprecated: boolean;
}>();

const deprecatedHTMLElementInterfaces = [
	"HTMLDirectoryElement",
	"HTMLFontElement",
	"HTMLFrameElement",
	"HTMLFrameSetElement",
	"HTMLMarqueeElement",
	"HTMLParamElement",
];

// let formProperties = [];

for (const match of domLib.matchAll(
	/^interface (?<name>HTML\w+Element|HTMLHyperlinkElementUtils|PopoverInvokerElement|LinkStyle) (?:extends (?<baseInterfaces>.+) )?{(?<content>(?:\n    .+)+\n)}/mg
)) {
	const interfaceName = match.groups.name;
	// const baseInterfaces = match.groups.baseInterfaces?.split(", ") ?? [];
	// console.log(interfaceName, baseInterfaces);
	if (deprecatedHTMLElementInterfaces.includes(interfaceName)) continue;
	// let isFormInterface = interfaceName === "HTMLFormElement";
	const members = match.groups.content.replaceAll("\n    ", "\n\t").split(";\n").slice(0, -1);
	for (const member of members) {
		const declarationLine = member.split("\n").at(-1).trim();
		let match: RegExpMatchArray;
		if (match = declarationLine.match(/^(?<isReadonly>readonly )?(?<propertyName>\w+)\??\: (?<definition>.+)$/)) {
			let { propertyName, definition, isReadonly } = match.groups;
			if (definition.match(/^\d+$/)) continue;
			let propertyInfo = propertyMap.get(propertyName);
			if (!propertyInfo) propertyMap.set(propertyName, propertyInfo = {
				definitions: new Set(),
				validFor: new Set(),
				deprecated: true,
				readonly: true,
			});
			if (!member.includes("@deprecated")) propertyInfo.deprecated = false;
			if (!isReadonly) {
				propertyInfo.readonly = false;
				// if (isFormInterface) formProperties.push(declarationLine);
			}
			propertyInfo.validFor.add(interfaceName);
			for (const subDefinition of definition.split(" | ")) propertyInfo.definitions.add(subDefinition);
		} else if (match = declarationLine.match(/^(?<functionName>\w+)[<(]/)) {
			let { functionName } = match.groups;
			if (["addEventListener", "removeEventListener"].includes(functionName)) continue;
			let functionInfo = functionMap.get(functionName);
			if (!functionInfo) functionMap.set(functionName, functionInfo = {
				overloads: new Set(),
				validFor: new Set(),
				deprecated: true,
			});
			if (!member.includes("@deprecated")) functionInfo.deprecated = false;
			functionInfo.validFor.add(interfaceName);
			functionInfo.overloads.add(declarationLine);
		} else {
			console.log(`skipped property/function ${declarationLine} (${interfaceName})`);
		}
	}
}

const listFormatter = new Intl.ListFormat("en-GB", {
	style: "long",
	type: "conjunction",
});

for (const [property, propertyInfo] of propertyMap) {
	if (
		propertyInfo.definitions.has("string")
		&& propertyInfo.definitions.size >= 2
		&& [...propertyInfo.definitions].some(definition => definition !== "number" && definition !== "string")
	) {
		// make strings autocompletable (see https://medium.com/@florian.schindler_47749/typescript-hacks-1-string-suggestions-58806363afeb)
		propertyInfo.definitions.add("(string & {})");
		propertyInfo.definitions.delete("string");
	}
}

const createJSDocLine = ({ deprecated, validFor }: { deprecated: boolean, validFor: Set<string>; }) => `\t\t/**${deprecated ? " @deprecated" : ""} Valid for ${(
	listFormatter.format(
		[...validFor].map(interfaceName => `{@link ${interfaceName}|\`${interfaceName}\`}`)
	)
)}. */`;

const result = [
	``,
	`// DO NOT EDIT THIS FILE DIRECTLY!`,
	`// This file was automatically generated via ./scripts/generate-generic-element-interface.ts`,
	``,
	`/// <reference lib="ESNext" />`,
	`/// <reference lib="DOM" />`,
	`/// <reference lib="DOM.Iterable" />`,
	`/// <reference lib="DOM.AsyncIterable" />`,
	``,
	`declare namespace WinzigInternals {`,
	`\tinterface WinzigGenericElement extends HTMLElement {`,
	[...propertyMap]
		.sort(([name1], [name2]) => name1 > name2 ? 1 : -1)
		.map(([name, info]) => [
			createJSDocLine(info),
			`\t\t${info.readonly ? "readonly " : ""}${name}: ${[...info.definitions].join(" | ")};`,
		].join("\n"))
		.join("\n"),
	[...functionMap].sort(([name1], [name2]) => name1 > name2 ? 1 : -1).map(([name, info]) => [
		createJSDocLine(info),
		`\t\t${[...info.overloads].join(";\n\t\t")};`,
	].join("\n")).join("\n"),
	`\t\t[name: number]: HTMLOptionElement | HTMLOptGroupElement;`,
	`\t\t[Symbol.iterator](): IterableIterator<HTMLOptionElement>;`,
	`\t}`,
	`}`,
	``,
].join("\n");

// console.log(formProperties);

FS.writeFile(Path.resolve(import.meta.dirname, "../generic-element.d.ts"), result);
